package integration

import (
	"aegis/integration/integration_test_cases"
	"testing"
)

func TestIntegration(t *testing.T) {
	t.Run("API", func(r *testing.T) {
		t.Run("calling GET /login returns 200 and shows login page when enabled", integration_test_cases.Login_NoATOrRT_Returns200AndShowsLoginPage)
		t.Run("calling GET /login with a valid access_token gets redirected to /login-success", integration_test_cases.Login_ValidAT_RedirectsToSuccessPage)
		t.Run("calling GET /login returns 404 when disabled", integration_test_cases.Login_DisabledReturns404)
		t.Run("calling GET /login-error returns 200 when enabled", integration_test_cases.LoginError_EnabledReturns200AndShowsErrorPage)
		t.Run("calling GET /login-error returns 404 when disabled", integration_test_cases.LoginError_DisabledReturns404)
		t.Run("calling GET /health returns 200", integration_test_cases.Health_200)
		t.Run("calling GET /logout sets zero cookies", integration_test_cases.Logout_SetsZeroCookies)
		t.Run("calling GET /logout without a refresh_token does not break", integration_test_cases.Logout_WithoutRefreshTokenDoesNotBreak)
		t.Run("calling GET /logout with a refresh_token deletes the refresh_token", integration_test_cases.Logout_DeletesRefreshToken)
		t.Run("calling GET /me without a session returns 401", integration_test_cases.Me_WithoutSessionReturns401)
		t.Run("calling GET /me with a session returns 200 and the session", integration_test_cases.Me_WithSessionReturns200)
		t.Run("calling GET /provider/callback returns 403 if the provider is not enabled", integration_test_cases.ProviderCallback_NotEnabledReturns403)
		t.Run("calling GET /provider/callback redirects to error page if state is invalid", integration_test_cases.ProviderCallback_MustRedirectToErrorPage_InvalidState)
		t.Run("calling GET /provider/callback redirects to error page if code is invalid", integration_test_cases.ProviderCallback_MustRedirectToErrorPage_InvalidCode)
		t.Run("calling GET /provider/callback redirects to error page if user declines auth", integration_test_cases.ProviderCallback_MustRedirectToErrorPage_UserDeclinesAuth)
		t.Run("calling GET /provider/callback redirects to error page if user is using another method", integration_test_cases.ProviderCallback_MustRedirectToErrorPage_UserUsingAnotherMethod)
		t.Run("calling GET /provider/callback redirects to error page if user is blocked", integration_test_cases.ProviderCallback_MustRedirectToErrorPage_UserBlocked)
		t.Run("calling GET /provider/callback redirects to error page if user is deleted", integration_test_cases.ProviderCallback_MustRedirectToErrorPage_UserDeleted)
		t.Run("calling GET /provider/callback redirects to error page if user is not an early adopter", integration_test_cases.ProviderCallback_MustRedirectToErrorPage_UserNotAnEarlyAdopter)
		t.Run("calling GET /provider/callback gives [access_token, refresh_token] if the user already exists", integration_test_cases.ProviderCallback_Success_UserExists)
		t.Run("calling GET /provider/callback gives [access_token, refresh_token] and creates userif the user does not exist", integration_test_cases.ProviderCallback_Success_UserDoesNotExist)
		t.Run("calling GET /provider/callback cleans the state", integration_test_cases.ProviderCallback_Success_CleansState)
		t.Run("calling GET /provider/callback redirects to the welcome page", integration_test_cases.ProviderCallback_Success_RedirectsToWelcomePage)
		t.Run("calling GET /provider returns 403 if the provider is not enabled", integration_test_cases.Provider_NotEnabledReturns403)
		t.Run("calling GET /provider returns 200 if the provider is enabled", integration_test_cases.Provider_EnabledReturnsUrlAndState)
		t.Run("calling GET /refresh (hard refresh) must not refresh the user (1) if user does not exist", func(t *testing.T) { /*todo*/ })
		t.Run("calling GET /refresh (hard refresh) must not refresh the user (1) if user is deleted", func(t *testing.T) { /*todo*/ })
		t.Run("calling GET /refresh (hard refresh) must not refresh the user (1) if user is blocked", func(t *testing.T) { /*todo*/ })
		t.Run("calling GET /refresh (hard refresh) must not refresh the user (1) if user is not an early adopter", func(t *testing.T) { /*todo*/ })
		t.Run("calling GET /refresh (hard refresh) must not refresh the user (2) if no refresh_token", integration_test_cases.HardRefresh_MustNotRefresh_EmptyRT)
		t.Run("calling GET /refresh (hard refresh) must not refresh the user (2) if expired refresh_token", integration_test_cases.HardRefresh_MustNotRefresh_ExpiredRT)
		t.Run("calling GET /refresh (hard refresh) must not refresh the user (2) if malformed refresh_token", integration_test_cases.HardRefresh_MustNotRefresh_MalformedRT)
		t.Run("calling GET /refresh (hard refresh) must refresh the user if access_token and refresh_token are valid", integration_test_cases.HardRefresh_MustRefresh_ValidTokens)
		t.Run("calling GET /refresh (hard refresh) must refresh the user if no access_token but refresh_token is valid", integration_test_cases.HardRefresh_MustRefresh_EmptyAT)
		t.Run("calling GET /refresh (hard refresh) must refresh the user if expired access_token and refresh_token is valid", integration_test_cases.HardRefresh_MustRefresh_ExpiredAT)
		t.Run("calling GET /refresh (hard refresh) must refresh the user if malformed access_token and refresh_token is valid", integration_test_cases.HardRefresh_MustRefresh_MalformedAT)
		t.Run("calling POST /authorize-access-token (test token) returns 401 if no token is provided", integration_test_cases.Authorize_EmptyTokenReturns401)
		t.Run("calling POST /authorize-access-token (test token) returns 401 if the token is expired", integration_test_cases.Authorize_ExpiredTokenReturns401)
		t.Run("calling POST /authorize-access-token (test token) returns 401 if the token is malformed", integration_test_cases.Authorize_MalformedTokenReturns401)
		t.Run("calling POST /authorize-access-token (test roles) returns 401 if no roles are provided", integration_test_cases.Authorize_NoRolesReturns401)
		t.Run("calling POST /authorize-access-token (test roles) returns 401 if the user does not have the required role", integration_test_cases.Authorize_UserDoesNotHaveRequiredRoleReturns401)
		t.Run("calling POST /authorize-access-token (test roles) returns 200 if the user has the required role", integration_test_cases.Authorize_UserHasRequiredRoleReturns200)
		t.Run("calling POST /authorize-access-token (test roles) returns 200 if the user has any role", integration_test_cases.Authorize_UserHasAnyRoleReturns200)
	})
	t.Run("Middlewares", func(t *testing.T) {
		t.Run("soft refresh: must not refresh the user (1) if user does not exist", func(t *testing.T) { /*todo*/ })
		t.Run("soft refresh: must not refresh the user (1) if user is deleted", func(t *testing.T) { /*todo*/ })
		t.Run("soft refresh: must not refresh the user (1) if user is blocked", func(t *testing.T) { /*todo*/ })
		t.Run("soft refresh: must not refresh the user (1) if user is not an early adopter", func(t *testing.T) { /*todo*/ })
		t.Run("soft refresh: must not refresh the user (2) if no refresh_token", integration_test_cases.SoftRefresh_MustNotRefresh_EmptyRT)
		t.Run("soft refresh: must not refresh the user (2) if expired refresh_token", integration_test_cases.SoftRefresh_MustNotRefresh_ExpiredRT)
		t.Run("soft refresh: must not refresh the user (2) if malformed refresh_token", integration_test_cases.SoftRefresh_MustNotRefresh_MalformedRT)
		t.Run("soft refresh: must not refresh the user (3) if access_token is valid", integration_test_cases.SoftRefresh_MustNotRefresh_ValidAT)
		t.Run("soft refresh: must refresh the user if no access_token but refresh_token is valid", integration_test_cases.SoftRefresh_MustRefresh_EmptyAT)
		t.Run("soft refresh: must refresh the user if expired access_token and refresh_token is valid", integration_test_cases.SoftRefresh_MustRefresh_ExpiredAT)
		t.Run("soft refresh: must refresh the user if malformed access_token and refresh_token is valid", integration_test_cases.SoftRefresh_MustRefresh_MalformedAT)
		t.Run("internal API call: must return 401 if no key is provided", integration_test_cases.MiddlewareInternalAPI_NoKeyReturns401)
		t.Run("internal API call: must return 401 if the key is invalid", integration_test_cases.MiddlewareInternalAPI_InvalidKeyReturns401)
	})
}
